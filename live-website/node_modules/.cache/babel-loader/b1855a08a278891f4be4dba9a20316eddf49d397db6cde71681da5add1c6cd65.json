{"ast":null,"code":"// Robust solver for the Zip puzzle, ported from Main_cpp_originalCode.cpp\n// Handles any m x n grid, only visits numbered cells (not blanks)\n\nfunction checkAllNumberedVisited(vis, mapNums) {\n  for (let i = 0; i < vis.length; ++i) for (let j = 0; j < vis[0].length; ++j) if (mapNums[i][j] !== -1 && !vis[i][j]) return false;\n  return true;\n}\nfunction isValidMove(curRow, curCol, nxtRow, nxtCol, m, n, vis, hWalls, vWalls, lastNum, newNum, prevRow, prevCol) {\n  if (nxtRow < 0 || nxtRow >= m || nxtCol < 0 || nxtCol >= n) return false;\n  if (vis[nxtRow][nxtCol]) return false;\n  if (nxtRow === prevRow && nxtCol === prevCol) return false;\n  if (newNum !== -1 && newNum < lastNum) return false;\n  // Right\n  if (nxtCol === curCol + 1 && (curCol >= n - 1 || hWalls[curRow][curCol] === 1)) return false;\n  // Left\n  if (nxtCol === curCol - 1 && (nxtCol < 0 || hWalls[curRow][nxtCol] === 1)) return false;\n  // Down\n  if (nxtRow === curRow + 1 && (curRow >= m - 1 || vWalls[curRow][curCol] === 1)) return false;\n  // Up\n  if (nxtRow === curRow - 1 && (nxtRow < 0 || vWalls[nxtRow][curCol] === 1)) return false;\n  return true;\n}\nfunction solve(mapNums, hWalls, vWalls, path, vis, row, col, lastNum, targetNum, res, pathFound) {\n  if (pathFound.found) return;\n  if (mapNums[row][col] === targetNum) {\n    if (checkAllNumberedVisited(vis, mapNums)) {\n      res.length = 0;\n      for (const p of path) res.push([...p]);\n      pathFound.found = true;\n    }\n    if (pathFound.found) return;\n  }\n  const m = mapNums.length,\n    n = mapNums[0].length;\n  let prevRow = -1,\n    prevCol = -1;\n  if (path.length >= 2) {\n    [prevRow, prevCol] = path[path.length - 2];\n  }\n  const dir = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n  for (let d = 0; d < 4; ++d) {\n    const [dr, dc] = dir[d];\n    const nr = row + dr,\n      nc = col + dc;\n    const num = nr >= 0 && nr < m && nc >= 0 && nc < n ? mapNums[nr][nc] : -2;\n    if (isValidMove(row, col, nr, nc, m, n, vis, hWalls, vWalls, lastNum, num, prevRow, prevCol)) {\n      vis[nr][nc] = true;\n      path.push([nr, nc]);\n      solve(mapNums, hWalls, vWalls, path, vis, nr, nc, Math.max(lastNum, mapNums[nr][nc]), targetNum, res, pathFound);\n      if (pathFound.found) return;\n      path.pop();\n      vis[nr][nc] = false;\n    }\n  }\n}\n\n// Main export: returns array of [row, col] for path, or [] if no solution\nexport default function solveZipPuzzle(the_map, h_walls, v_walls) {\n  const m = the_map.length,\n    n = the_map[0].length;\n  let startRow = -1,\n    startCol = -1,\n    targetNum = 0;\n  for (let i = 0; i < m; ++i) for (let j = 0; j < n; ++j) {\n    if (the_map[i][j] === 1) {\n      startRow = i;\n      startCol = j;\n    }\n    if (the_map[i][j] !== -1) targetNum = Math.max(targetNum, the_map[i][j]);\n  }\n  if (startRow === -1) throw new Error('Starting point (1) not found in matrix');\n  const vis = Array.from({\n    length: m\n  }, () => Array(n).fill(false));\n  vis[startRow][startCol] = true;\n  const path = [[startRow, startCol]];\n  const res = [];\n  const pathFound = {\n    found: false\n  };\n  solve(the_map, h_walls, v_walls, path, vis, startRow, startCol, the_map[startRow][startCol], targetNum, res, pathFound);\n  return pathFound.found ? res : [];\n}","map":{"version":3,"names":["checkAllNumberedVisited","vis","mapNums","i","length","j","isValidMove","curRow","curCol","nxtRow","nxtCol","m","n","hWalls","vWalls","lastNum","newNum","prevRow","prevCol","solve","path","row","col","targetNum","res","pathFound","found","p","push","dir","d","dr","dc","nr","nc","num","Math","max","pop","solveZipPuzzle","the_map","h_walls","v_walls","startRow","startCol","Error","Array","from","fill"],"sources":["/Users/shreyashkiranchaudhari/Desktop/Projects/DSA-Zip/Github_Clone_website/Linkedin_Zip_Solver/live-website/src/solver.js"],"sourcesContent":["// Robust solver for the Zip puzzle, ported from Main_cpp_originalCode.cpp\n// Handles any m x n grid, only visits numbered cells (not blanks)\n\nfunction checkAllNumberedVisited(vis, mapNums) {\n  for (let i = 0; i < vis.length; ++i)\n    for (let j = 0; j < vis[0].length; ++j)\n      if (mapNums[i][j] !== -1 && !vis[i][j]) return false;\n  return true;\n}\n\nfunction isValidMove(curRow, curCol, nxtRow, nxtCol, m, n, vis, hWalls, vWalls, lastNum, newNum, prevRow, prevCol) {\n  if (nxtRow < 0 || nxtRow >= m || nxtCol < 0 || nxtCol >= n) return false;\n  if (vis[nxtRow][nxtCol]) return false;\n  if (nxtRow === prevRow && nxtCol === prevCol) return false;\n  if (newNum !== -1 && newNum < lastNum) return false;\n  // Right\n  if (nxtCol === curCol + 1 && (curCol >= n - 1 || hWalls[curRow][curCol] === 1)) return false;\n  // Left\n  if (nxtCol === curCol - 1 && (nxtCol < 0 || hWalls[curRow][nxtCol] === 1)) return false;\n  // Down\n  if (nxtRow === curRow + 1 && (curRow >= m - 1 || vWalls[curRow][curCol] === 1)) return false;\n  // Up\n  if (nxtRow === curRow - 1 && (nxtRow < 0 || vWalls[nxtRow][curCol] === 1)) return false;\n  return true;\n}\n\nfunction solve(mapNums, hWalls, vWalls, path, vis, row, col, lastNum, targetNum, res, pathFound) {\n  if (pathFound.found) return;\n  if (mapNums[row][col] === targetNum) {\n    if (checkAllNumberedVisited(vis, mapNums)) {\n      res.length = 0;\n      for (const p of path) res.push([...p]);\n      pathFound.found = true;\n    }\n    if (pathFound.found) return;\n  }\n  const m = mapNums.length, n = mapNums[0].length;\n  let prevRow = -1, prevCol = -1;\n  if (path.length >= 2) {\n    [prevRow, prevCol] = path[path.length - 2];\n  }\n  const dir = [\n    [-1, 0], [1, 0], [0, -1], [0, 1]\n  ];\n  for (let d = 0; d < 4; ++d) {\n    const [dr, dc] = dir[d];\n    const nr = row + dr, nc = col + dc;\n    const num = (nr >= 0 && nr < m && nc >= 0 && nc < n) ? mapNums[nr][nc] : -2;\n    if (\n      isValidMove(row, col, nr, nc, m, n, vis, hWalls, vWalls, lastNum, num, prevRow, prevCol)\n    ) {\n      vis[nr][nc] = true;\n      path.push([nr, nc]);\n      solve(mapNums, hWalls, vWalls, path, vis, nr, nc, Math.max(lastNum, mapNums[nr][nc]), targetNum, res, pathFound);\n      if (pathFound.found) return;\n      path.pop();\n      vis[nr][nc] = false;\n    }\n  }\n}\n\n// Main export: returns array of [row, col] for path, or [] if no solution\nexport default function solveZipPuzzle(the_map, h_walls, v_walls) {\n  const m = the_map.length, n = the_map[0].length;\n  let startRow = -1, startCol = -1, targetNum = 0;\n  for (let i = 0; i < m; ++i)\n    for (let j = 0; j < n; ++j) {\n      if (the_map[i][j] === 1) { startRow = i; startCol = j; }\n      if (the_map[i][j] !== -1) targetNum = Math.max(targetNum, the_map[i][j]);\n    }\n  if (startRow === -1) throw new Error('Starting point (1) not found in matrix');\n  const vis = Array.from({ length: m }, () => Array(n).fill(false));\n  vis[startRow][startCol] = true;\n  const path = [[startRow, startCol]];\n  const res = [];\n  const pathFound = { found: false };\n  solve(the_map, h_walls, v_walls, path, vis, startRow, startCol, the_map[startRow][startCol], targetNum, res, pathFound);\n  return pathFound.found ? res : [];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}