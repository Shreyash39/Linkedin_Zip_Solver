{"ast":null,"code":"// Ported from your Main.cpp to JS\nfunction clone2D(arr) {\n  return arr.map(row => row.slice());\n}\nfunction checkAllVisited(vis) {\n  for (const row of vis) for (const v of row) if (!v) return false;\n  return true;\n}\nfunction isValidMove(curRow, curCol, nxtRow, nxtCol, m, n, vis, hWalls, vWalls, lastNum, newNum, prevRow, prevCol) {\n  if (nxtRow < 0 || nxtRow >= m || nxtCol < 0 || nxtCol >= n) return false;\n  if (vis[nxtRow][nxtCol]) return false;\n  if (nxtRow === prevRow && nxtCol === prevCol) return false;\n  if (newNum !== -1 && newNum < lastNum) return false;\n  // Right\n  if (nxtCol === curCol + 1 && (curCol >= n - 1 || hWalls[curRow][curCol] === 1)) return false;\n  // Left\n  if (nxtCol === curCol - 1 && (nxtCol < 0 || hWalls[curRow][nxtCol] === 1)) return false;\n  // Down\n  if (nxtRow === curRow + 1 && (curRow >= m - 1 || vWalls[curRow][curCol] === 1)) return false;\n  // Up\n  if (nxtRow === curRow - 1 && (nxtRow < 0 || vWalls[nxtRow][curCol] === 1)) return false;\n  return true;\n}\nfunction solve(mapNums, hWalls, vWalls, path, vis, row, col, lastNum, targetNum, res, pathFound) {\n  if (pathFound.found) return;\n  if (mapNums[row][col] === targetNum) {\n    if (checkAllVisited(vis)) {\n      res.length = 0;\n      for (const p of path) res.push([...p]);\n      pathFound.found = true;\n    }\n    if (pathFound.found) return;\n  }\n  const m = mapNums.length,\n    n = mapNums[0].length;\n  let prevRow = -1,\n    prevCol = -1;\n  if (path.length >= 2) {\n    [prevRow, prevCol] = path[path.length - 2];\n  }\n  const dir = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n  for (let d = 0; d < 4; ++d) {\n    const [dr, dc] = dir[d];\n    const nr = row + dr,\n      nc = col + dc;\n    const num = nr >= 0 && nr < m && nc >= 0 && nc < n ? mapNums[nr][nc] : -2;\n    if (isValidMove(row, col, nr, nc, m, n, vis, hWalls, vWalls, lastNum, num, prevRow, prevCol)) {\n      vis[nr][nc] = true;\n      path.push([nr, nc]);\n      solve(mapNums, hWalls, vWalls, path, vis, nr, nc, Math.max(lastNum, mapNums[nr][nc]), targetNum, res, pathFound);\n      if (pathFound.found) return;\n      path.pop();\n      vis[nr][nc] = false;\n    }\n  }\n}\n\n// Main export: returns array of [row, col] for path, or [] if no solution\nexport default function solveZipPuzzle(the_map, h_walls, v_walls) {\n  const m = the_map.length,\n    n = the_map[0].length;\n  let startRow = -1,\n    startCol = -1,\n    targetNum = 0;\n  for (let i = 0; i < m; ++i) for (let j = 0; j < n; ++j) {\n    if (the_map[i][j] === 1) {\n      startRow = i;\n      startCol = j;\n    }\n    if (the_map[i][j] !== -1) targetNum = Math.max(targetNum, the_map[i][j]);\n  }\n  if (startRow === -1) throw new Error('Starting point (1) not found in matrix');\n  const vis = Array.from({\n    length: m\n  }, () => Array(n).fill(false));\n  vis[startRow][startCol] = true;\n  const path = [[startRow, startCol]];\n  const res = [];\n  const pathFound = {\n    found: false\n  };\n  solve(the_map, h_walls, v_walls, path, vis, startRow, startCol, the_map[startRow][startCol], targetNum, res, pathFound);\n  return pathFound.found ? res : [];\n}","map":{"version":3,"names":["clone2D","arr","map","row","slice","checkAllVisited","vis","v","isValidMove","curRow","curCol","nxtRow","nxtCol","m","n","hWalls","vWalls","lastNum","newNum","prevRow","prevCol","solve","mapNums","path","col","targetNum","res","pathFound","found","length","p","push","dir","d","dr","dc","nr","nc","num","Math","max","pop","solveZipPuzzle","the_map","h_walls","v_walls","startRow","startCol","i","j","Error","Array","from","fill"],"sources":["/Users/shreyashkiranchaudhari/Desktop/Projects/DSA-Zip/Github_Clone_website/Linkedin_Zip_Solver/live-website/src/solver.js"],"sourcesContent":["// Ported from your Main.cpp to JS\nfunction clone2D(arr) {\n  return arr.map(row => row.slice());\n}\n\nfunction checkAllVisited(vis) {\n  for (const row of vis) for (const v of row) if (!v) return false;\n  return true;\n}\n\nfunction isValidMove(curRow, curCol, nxtRow, nxtCol, m, n, vis, hWalls, vWalls, lastNum, newNum, prevRow, prevCol) {\n  if (nxtRow < 0 || nxtRow >= m || nxtCol < 0 || nxtCol >= n) return false;\n  if (vis[nxtRow][nxtCol]) return false;\n  if (nxtRow === prevRow && nxtCol === prevCol) return false;\n  if (newNum !== -1 && newNum < lastNum) return false;\n  // Right\n  if (nxtCol === curCol + 1 && (curCol >= n - 1 || hWalls[curRow][curCol] === 1)) return false;\n  // Left\n  if (nxtCol === curCol - 1 && (nxtCol < 0 || hWalls[curRow][nxtCol] === 1)) return false;\n  // Down\n  if (nxtRow === curRow + 1 && (curRow >= m - 1 || vWalls[curRow][curCol] === 1)) return false;\n  // Up\n  if (nxtRow === curRow - 1 && (nxtRow < 0 || vWalls[nxtRow][curCol] === 1)) return false;\n  return true;\n}\n\nfunction solve(mapNums, hWalls, vWalls, path, vis, row, col, lastNum, targetNum, res, pathFound) {\n  if (pathFound.found) return;\n  if (mapNums[row][col] === targetNum) {\n    if (checkAllVisited(vis)) {\n      res.length = 0;\n      for (const p of path) res.push([...p]);\n      pathFound.found = true;\n    }\n    if (pathFound.found) return;\n  }\n  const m = mapNums.length, n = mapNums[0].length;\n  let prevRow = -1, prevCol = -1;\n  if (path.length >= 2) {\n    [prevRow, prevCol] = path[path.length - 2];\n  }\n  const dir = [\n    [-1, 0], [1, 0], [0, -1], [0, 1]\n  ];\n  for (let d = 0; d < 4; ++d) {\n    const [dr, dc] = dir[d];\n    const nr = row + dr, nc = col + dc;\n    const num = (nr >= 0 && nr < m && nc >= 0 && nc < n) ? mapNums[nr][nc] : -2;\n    if (\n      isValidMove(row, col, nr, nc, m, n, vis, hWalls, vWalls, lastNum, num, prevRow, prevCol)\n    ) {\n      vis[nr][nc] = true;\n      path.push([nr, nc]);\n      solve(mapNums, hWalls, vWalls, path, vis, nr, nc, Math.max(lastNum, mapNums[nr][nc]), targetNum, res, pathFound);\n      if (pathFound.found) return;\n      path.pop();\n      vis[nr][nc] = false;\n    }\n  }\n}\n\n// Main export: returns array of [row, col] for path, or [] if no solution\nexport default function solveZipPuzzle(the_map, h_walls, v_walls) {\n  const m = the_map.length, n = the_map[0].length;\n  let startRow = -1, startCol = -1, targetNum = 0;\n  for (let i = 0; i < m; ++i)\n    for (let j = 0; j < n; ++j) {\n      if (the_map[i][j] === 1) { startRow = i; startCol = j; }\n      if (the_map[i][j] !== -1) targetNum = Math.max(targetNum, the_map[i][j]);\n    }\n  if (startRow === -1) throw new Error('Starting point (1) not found in matrix');\n  const vis = Array.from({ length: m }, () => Array(n).fill(false));\n  vis[startRow][startCol] = true;\n  const path = [[startRow, startCol]];\n  const res = [];\n  const pathFound = { found: false };\n  solve(the_map, h_walls, v_walls, path, vis, startRow, startCol, the_map[startRow][startCol], targetNum, res, pathFound);\n  return pathFound.found ? res : [];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}